<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>RuboClaus by mojotech</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">RuboClaus</h1><img src='https://github.com/mojotech/rubo_claus/blob/gh-pages/images/santaicon.png?raw=true' >
      <h2 class="project-tagline">Ruby method pattern matching inspired by functional programming with Elixir and Erlang</h2>
      <a href="https://github.com/mojotech/rubo_claus" class="btn">View on GitHub</a>
      <a href="https://github.com/mojotech/rubo_claus/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mojotech/rubo_claus/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="ruboclaus" class="anchor" href="#ruboclaus" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RuboClaus</h1>
<code>gem install rubo_claus</code>
<p>RuboClaus is an open source project that gives the Ruby developer a DSL to implement functions with multiple clauses and varying numbers of arguments on a pattern matching paradigm, inspired by functional programming in Elixir and Erlang.</p>

<h4>
<a id="note" class="anchor" href="#note" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Note</h4>

<p><em>RuboClaus is still in very early stage of development and thought process.  We are still treating this as a proof-of-concept and are still exploring the topic.  As such, we don't suggest you use this in any kind of production environment, without first looking at the library code and feeling comfortable with how it works.  And, if you would like to continue this thought experiment and provide feedback/suggestions/changes, we would love to hear it.</em></p>

<h3>
<a id="rationale" class="anchor" href="#rationale" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rationale</h3>

<p>The beauty of multiple function clauses with pattern matching is fewer conditionals and fewer lines of unnecessary defensive logic. Focus on the happy path. Control types as they come in, and handle for edge cases with catch all clauses. It does not work great for simple methods, like this:</p>

<p>Ruby:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">def</span> <span class="pl-en">add</span>(<span class="pl-smi">first</span>, <span class="pl-smi">second</span>)
  <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>Please use numbers<span class="pl-pds">"</span></span> <span class="pl-k">unless</span> [first, second].all? { |<span class="pl-smi">obj</span>| obj.is_a? <span class="pl-c1">Fixnum</span> }
  first <span class="pl-k">+</span> second
<span class="pl-k">end</span></pre></div>

<p>Ruby With RuboClaus:</p>

<div class="highlight highlight-source-ruby"><pre>define_function <span class="pl-c1">:add</span> <span class="pl-k">do</span>
  clauses(
    clause([<span class="pl-c1">Fixnum</span>, <span class="pl-c1">Fixnum</span>], proc { |<span class="pl-smi">first</span>, <span class="pl-smi">second</span>| first <span class="pl-k">+</span> second }),
    catch_all(proc { <span class="pl-s"><span class="pl-pds">"</span>Please use numbers<span class="pl-pds">"</span></span> }
  )
<span class="pl-k">end</span></pre></div>

<p>It is cumbersome for problems like <code>add</code>--in which case we don't recommend using it. But as soon as we add complexity that depends on parameter arity or type, we can see how RuboClaus makes our code more extendible and maintainable. For example:</p>

<p>Ruby:</p>

<div class="highlight highlight-source-ruby"><pre><span class="pl-k">def</span> <span class="pl-en">handle_response</span>(<span class="pl-smi">status</span>, <span class="pl-smi">has_body</span>, <span class="pl-smi">is_chunked</span>)
  <span class="pl-k">if</span> status <span class="pl-k">==</span> <span class="pl-c1">200</span> <span class="pl-k">&amp;&amp;</span> has_body <span class="pl-k">&amp;&amp;</span> is_chunked
    <span class="pl-c"># ...</span>
  <span class="pl-k">else</span>
    <span class="pl-k">if</span> status <span class="pl-k">==</span> <span class="pl-c1">200</span> <span class="pl-k">&amp;&amp;</span> has_body <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>is_chunked
      <span class="pl-c"># ...</span>
    <span class="pl-k">else</span>
      <span class="pl-k">if</span> status <span class="pl-k">==</span> <span class="pl-c1">200</span> <span class="pl-k">&amp;&amp;</span> <span class="pl-k">!</span>has_body
        <span class="pl-c"># ...</span>
      <span class="pl-k">else</span>
        <span class="pl-c"># ...</span>
      <span class="pl-k">end</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre></div>

<p>Ruby with RuboClaus:</p>

<div class="highlight highlight-source-ruby"><pre>define_function <span class="pl-c1">:handle_response</span> <span class="pl-k">do</span>
  clauses(
    clause([<span class="pl-c1">200</span>, <span class="pl-c1">true</span>, <span class="pl-c1">true</span>], proc { |<span class="pl-smi">status</span>, <span class="pl-smi">has_body</span>, <span class="pl-smi">is_chunked</span>| ... }),
    clause([<span class="pl-c1">200</span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>], proc { |<span class="pl-smi">status</span>, <span class="pl-smi">has_body</span>, <span class="pl-smi">is_chunked</span>| ... }),
    clause([<span class="pl-c1">200</span>, <span class="pl-c1">false</span>], proc { |<span class="pl-smi">status</span>, <span class="pl-smi">has_body</span>| ... }),
    catch_all(proc { return_error })
  )
<span class="pl-k">end</span></pre></div>

<p><a href="https://www.reddit.com/r/elixir/comments/34jyto/what_are_the_benefits_of_pattern_matching_as/cqve33n">Credit</a></p>

<p>To learn more about this style of programming read about <a href="https://en.wikipedia.org/wiki/Function_overloading">function overloading</a> and <a href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h2>

<p>Below are the public API methods and their associated arguments.</p>

<ul>
<li>
<code>define_function</code>

<ul>
<li>Symbol - name of the method to define</li>
<li>Block - a single block with a <code>clauses</code> method call</li>
</ul>
</li>
<li>
<code>clauses</code>

<ul>
<li>N number of <code>clause</code> method calls and/or a single <code>catch_all</code> method call</li>
</ul>
</li>
<li>
<code>clause</code> | <code>p_clause</code>

<ul>
<li>Array - list of arguments to pattern match against

<ul>
<li>Keywords:

<ul>
<li>
<code>:any</code> - among your arguments, <code>:any</code> represents that any data type will be accepted in its position.</li>
<li>
<code>:tail</code> - given an array argument with defined "head" elements and <code>:tail</code> as the last element (such as <code>[String, String, :tail]</code>), this will destructure the head elements and make the tail an array of the non-head elements.</li>
</ul>
</li>
</ul>
</li>
<li>Proc - method body to execute when this method is matched and executed</li>
<li>Note on <code>p_clause</code> - only visible to other clauses in the function, and will return <code>NoPatternMatchError</code> if invoked with matching parameters external to the function. Ideally used when calling the function recursively with different arity than the public api to the method.</li>
</ul>
</li>
<li>
<code>catch_all</code>

<ul>
<li>Proc - method body that will be executed if the arguments do not match any of the <code>clause</code> patterns defined</li>
</ul>
</li>
</ul>

<h3>
<a id="clause-pattern-arguments" class="anchor" href="#clause-pattern-arguments" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Clause pattern arguments</h3>

<p>The first argument to the <code>clause</code> method is an array of pattern match options.  This array can vary in length, and values depending on your pattern match case.</p>

<p>You can match against specific values:</p>

<div class="highlight highlight-source-ruby"><pre>clause([<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>], proc {...})
clause([<span class="pl-c1">42</span>], proc {...})
clause([<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-c1">:darth_vader</span>], proc {...})</pre></div>

<p>You can match against specifc argument types:</p>

<div class="highlight highlight-source-ruby"><pre>clause([<span class="pl-c1">String</span>], proc {...})
clause([<span class="pl-c1">Fixnum</span>], proc {...})
clause([<span class="pl-c1">String</span>, <span class="pl-c1">Symbol</span>], proc {...})</pre></div>

<p>You can match against specific values and types:</p>

<div class="highlight highlight-source-ruby"><pre>clause([<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-c1">String</span>], proc {...})
clause([<span class="pl-c1">42</span>, <span class="pl-c1">Fixnum</span>], proc {...})
clause([<span class="pl-c1">String</span>, <span class="pl-c1">:darth_vader</span>], proc {...})</pre></div>

<p>You also can match against any value or type if you don't have a specific requirement for an argument by using the <code>:any</code> symbol.</p>

<div class="highlight highlight-source-ruby"><pre>clause([<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-c1">:any</span>], proc {...})
clause([<span class="pl-c1">:any</span>], proc {...})
clause([<span class="pl-c1">42</span>, <span class="pl-c1">:any</span>], proc {...})</pre></div>

<p>You also can destructure an array with <code>:tail</code>.</p>

<div class="highlight highlight-source-ruby"><pre>clause([<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, [<span class="pl-c1">Fixnum</span>, <span class="pl-c1">:tail</span>]], proc { |<span class="pl-smi">string</span>, <span class="pl-smi">number</span>, <span class="pl-smi">tail_array</span>| ...  })
clause([<span class="pl-c1">Hash</span>, [<span class="pl-c1">Fixnum</span>, <span class="pl-c1">Fixnum</span> <span class="pl-c1">:tail</span>]], proc { |<span class="pl-smi">hash</span>, <span class="pl-smi">number1</span>, <span class="pl-smi">number2</span>,  <span class="pl-smi">tail_array</span>| ... })</pre></div>

<h3>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h3>

<p>Please see the <a href="https://github.com/mojotech/rubo_claus/tree/master/examples">examples directory</a> for various example use cases.  Most examples include direct comparisons of the Ruby code to a similar implementation in Elixir.</p>

<h2>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Development</h2>

<p>Don't introduce unneeded external dependencies.</p>

<p>Nothing else special to note for development.  Just add tests associated to any code changes and make sure they pass.</p>

<h2>
<a id="todo" class="anchor" href="#todo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TODO</h2>

<ul>
<li>[ ] Rename public API methods? <code>define_function</code> is awkward since Ruby uses the term <code>method</code> instead of <code>function</code>
</li>
<li>[ ] Add Benchmarks to see performance implications</li>
<li>[ ] Support private clauses to enforce a single entry point to a defined function</li>
</ul>

<hr>

<p><a href="https://travis-ci.org/mojotech/rubo_claus"><img src="https://travis-ci.org/mojotech/rubo_claus.svg?branch=master" alt="Build Status"></a>
<a href="https://github.com/dwyl/esta/issues"><img src="https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat" alt="contributions welcome"></a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mojotech/rubo_claus">RuboClaus</a> is maintained by <a href="https://github.com/mojotech">mojotech</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
